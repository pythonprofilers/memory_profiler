#! /usr/bin/env python

import glob
import os
import os.path as osp
import sys
import re

from optparse import OptionParser

import memory_profiler as mp


def print_usage():
    print("Usage: %s <command> <options> <arguments>"
          % osp.basename(sys.argv[0]))

def get_action():
    """Pop first argument, check it is a valid action."""
    all_actions = ("rm",)
    if len(sys.argv) <= 1:
        print_usage()
        sys.exit(1)
    if not sys.argv[1] in all_actions:
        print("Valid actions are: " + " ".join(all_actions))
        sys.exit(1)

    return sys.argv.pop(1)


def get_profile_filenames(args):
    """Return list of profile filenames.

    Parameters
    ==========
    args (list)
        list of filename or integer. An integer is the index of the
        profile in the list of existing profiles. 0 is the oldest,
        -1 in the more recent.
        Non-existing files cause a ValueError exception to be thrown.

    Returns
    =======
    filenames (list)
        list of existing memory profile filenames. It is guaranteed
        that an given file name will not appear twice in this list.
    """
    profiles = glob.glob("mprofile_??????????????.dat")
    profiles.sort()

    filenames = []

    for arg in args:
        if arg == "--":  # workaround
            continue
        try:
            index = int(arg)
        except ValueError:
            index = None
        if index is not None:
            try:
                filename = profiles[index]
            except IndexError:
                raise ValueError("Invalid index (non-existing file): %s" % arg)

            if filename not in filenames:
                filenames.append(filename)
        else:
            if osp.isfile(arg):
                if arg not in filenames:
                    filenames.append(arg)
            elif osp.isdir(arg):
                raise ValueError("Path %s is a directory" % arg)
            else:
                raise ValueError("File %s not found" % arg)

    # Add timestamp files, if any
    for filename in reversed(filenames):
        parts = osp.splitext(filename)
        timestamp_file = parts[0] + "_ts" + parts[1]
        if osp.isfile(timestamp_file) and timestamp_file not in filenames:
            filenames.append(timestamp_file)

    return filenames


def rm_action():
    parser = OptionParser(version=mp.__version__)
    parser.disable_interspersed_args()
    parser.add_option("--dry-run", dest="dry_run", default=False,
                      action="store_true",
                      help="""Show what will be done, without actually doing it.""")

    (options, args) = parser.parse_args()

    if len(args) == 0:
        print("A profile to remove must be provided (number or filename)")
        sys.exit(1)

    filenames = get_profile_filenames(args)
    if options.dry_run:
        print("Files to be removed: ")
        for filename in filenames:
            print(filename)
    else:
        for filename in filenames:
            os.remove(filename)


if __name__ == "__main__":
    # Workaround for optparse limitation: insert -- before first negative number found.
    negint = re.compile("-[0-9]+")
    for n, arg in enumerate(sys.argv):
        if negint.match(arg):
            sys.argv.insert(n, "--")
            break
    actions = {"rm": rm_action}
    actions[get_action()]()


